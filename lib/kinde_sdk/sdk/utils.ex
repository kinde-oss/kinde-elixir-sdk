defmodule KindeSDK.SDK.Utils do
  @moduledoc """
  Utility Functions for Kinde SDK

  This module provides a collection of utility functions used in the Kinde Software
  Development Kit (SDK). These functions cover a range of tasks such as encoding and
  decoding data, generating random values, validating URLs, parsing JSON Web Tokens (JWTs), and more.

  ## Usage Example

  To generate a challenge for OAuth2 authorization code flow, you can use the
  `generate_challenge/0` function as follows:

  ```elixir
    challenge = KindeSDK.SDK.Utils.generate_challenge()
  ```
  This module is an essential part of the Kinde SDK and is designed to simplify
  common tasks associated with Kinde application development.
  """
  @length 32

  ## Encodes a string as a Base64 URL-safe string.
  ## This function takes a binary string and encodes it as a Base64 URL-safe string.
  ## It removes padding characters ('=') and replaces '+' with '-' and '/' with '_'.
  defp base64_url_encode(string) do
    string
    |> Base.url_encode64()
    |> String.trim()
    |> String.replace("=", "")
    |> String.replace("+", "-")
    |> String.replace("/", "_")
  end

  @doc """
  Generate a random string of a specified length.

  This function generates a random binary string of the specified length and
  encodes it as a Base64 URL-safe string.

  ## Parameters

  - `length` (integer): The length of the random string. (default: 32)

  ## Returns

  A Base64 URL-safe encoded binary string.
  """
  @spec random_string(any) :: binary
  def random_string(length \\ @length) do
    :crypto.strong_rand_bytes(length)
    |> Base.encode16()
    |> base64_url_encode()
  end

  @doc """
  Generate a challenge for OAuth2 authorization code flow.

  This function generates a challenge for OAuth2 authorization code flow.
  It includes a random `state`, a random `code_verifier`, and a `code_challenge`
  generated by hashing the `code_verifier` with SHA-256 and encoding it as a Base64 URL-safe string.

  ## Returns

  A map containing `code_challenge`, `code_verifier`, and `state`.
  """
  @spec generate_challenge :: %{code_challenge: binary, code_verifier: binary, state: binary}
  def generate_challenge do
    state = random_string()
    code_verifier = random_string()
    code_challenge = :crypto.hash(:sha256, code_verifier) |> Base.url_encode64(padding: false)

    %{
      state: state,
      code_verifier: code_verifier,
      code_challenge: code_challenge
    }
  end

  @doc """
  Validate a URL.

  This function validates whether a given binary string is a valid URL using a regular expression.

  ## Parameters

  - `url` (binary): The URL to be validated.

  ## Returns

  `true` if the URL is valid, `false` otherwise.
  """
  @spec validate_url(binary) :: boolean
  def validate_url(url) do
    Regex.match?(
      ~r/https?:\/\/(?:w{1,3}\.)?[^\s.]+(?:\.[a-z]+)*(?::\d+)?(?![^<]*(?:<\/\w+>|\/?>))/,
      url
    )
  end

  @doc """
  Parse a JSON Web Token (JWT).

  This function takes a JWT as a binary string and parses it into a map.

  ## Parameters

  - `token` (nil | binary): The JWT token to be parsed.

  ## Returns

  A map representing the JWT payload, or `nil` if the input is `nil`.
  """
  @spec parse_jwt(nil | binary) :: any
  def parse_jwt(nil), do: nil

  def parse_jwt(token) do
    String.split(token, ".")
    |> Enum.at(1)
    |> String.replace("-", "+")
    |> String.replace("_", "/")
    |> Base.decode64!(padding: false)
    |> Jason.decode!()
  end

  @additional_param_keys [:audience, :org_code, :org_name, :is_create_org]

  @doc """
  Check and filter additional parameters.

  This function checks a map of parameters to ensure they match the predefined
  additional parameter keys and are of binary type. It returns a map containing
  only the valid additional parameters.

  ## Parameters

  - `params` (map): The map of parameters to check.

  ## Returns

  A filtered map containing only valid additional parameters.
  """
  @spec check_additional_params(map) :: map
  def check_additional_params(params) when params == %{}, do: %{}

  def check_additional_params(params) do
    keys = Map.keys(params)

    for key <- keys do
      if !(key in @additional_param_keys) do
        throw("Please provide correct additional, #{key}")
      end

      if !is_binary(Map.get(params, key)) do
        throw("Please supply a valid #{key}. Expected: string")
      end
    end

    params
  end

  @doc """
  Add additional parameters to a target map.

  This function takes a target map and additional parameters, checks and
  filters the additional parameters, and merges them into the target map.

  ## Parameters

  - `target` (map): The target map to which additional parameters will be added.
  - `additional_params` (map): The map of additional parameters to be added.

  ## Returns

  A map containing the merged target map with valid additional parameters.
  """
  @spec add_additional_params(map, map) :: map
  def add_additional_params(target, additional_params) do
    additional_params
    |> check_additional_params()
    |> Map.merge(target)
  end

  @doc """
  Get the current application version from Mix configuration.

  This function retrieves the current application version from Mix
  configuration and performs some string manipulation to extract the version number.

  ## Returns

  The current application version as a binary string.
  """
  @spec get_current_app_version :: binary
  def get_current_app_version() do
   # Using Application.spec(:vsn) to fetch the application version, suitable for production environments.
    :kinde_sdk
    |> Application.spec(:vsn)
    |> to_string()
  end

  @doc """
  Calculate the timestamp when a login will expire.

  This function takes a login timestamp and the duration of validity,
  and calculates the timestamp when the login will expire.

  ## Parameters

  - `login_timestamp` (DateTime): The timestamp of the login.
  - `expiring_in` (integer): The duration of validity in seconds.

  ## Returns

  The timestamp when the login will expire.
  """
  def calculate_expiring_timestamp(login_timestamp, expiring_in) do
    {:ok, expiring_at} =
      login_timestamp
      |> DateTime.to_unix()
      |> Kernel.+(expiring_in)
      |> DateTime.from_unix()

    expiring_at
  end
end

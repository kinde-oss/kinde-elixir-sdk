defmodule KindeClientSDK do
  @moduledoc """
  Kinde Client supporting `client_credentials`, `authorization_code` and `pkce` OAuth2 methods,
  providing authentication functionalities to your Kinde business.

  ## Configuration

  ### API Keys

  You can set your keys in your application configuration. Use `config/config.exs`.
  For example:

      config :kinde_sdk,
        backend_client_id: "test_x1y2z3a1",
        frontend_client_id: "test_a1b2c3d4",
        client_secret: "test_112233",
        redirect_url: "http://text.com/callback",
        domain: "https://test.kinde.com",
        logout_redirect_url: "http://text.com/logout"

  Optionally, you can also set `scope` as well.
      config :kinde_sdk,
        scope: "email"

  You can also use `System.get_env/1` to retrieve the API key from
  an environment variables. For example:

  config :kinde_sdk,
        backend_client_id: System.get_env("KINDE_BACKEND_CLIENT_ID")

  ## Usage

  Initialize your client like this:

      {conn, client} =
        KindeClientSDK.init(
          conn,
          Application.get_env(:kinde_sdk, :domain),
          Application.get_env(:kinde_sdk, :redirect_url),
          Application.get_env(:kinde_sdk, :backend_client_id),
          Application.get_env(:kinde_sdk, :client_secret),
          :client_credentials,
          Application.get_env(:kinde_sdk, :logout_redirect_url)
        )

  `conn` will be phoenix connection here here. Now, you can use other implemented client functions,
  like `login` and `get_token`.

  ### ETS Cache

  KindeClientSDK implements persistant ETS cache for storing the client data and authenticating
  variables.

  You may call your created client like this:

        client = KindeClientSDK.get_kinde_client(conn)

  ### Tokens

  We can use Kinde cache to get the tokens generated by `login` and `get_token` functions.

        KindeClientSDK.get_all_data(conn)
  """
  alias KindeSDK.SDK.AuthorizationCode
  alias KindeSDK.SDK.ClientCredentials
  alias KindeSDK.SDK.Utils
  alias KindeSDK.SDK.Pkce
  alias KindeSDK.KindeCache
  alias Plug.Conn
  use Tesla

  @authorization_end_point "/oauth2/auth"
  @token_end_point "/oauth2/token"
  @logout_end_point "/logout"

  @enforce_keys [
    :cache_pid,
    :domain,
    :redirect_uri,
    :client_secret,
    :client_id,
    :grant_type,
    :logout_endpoint
  ]
  defstruct [
    :cache_pid,
    :domain,
    :redirect_uri,
    :logout_redirect_uri,
    :client_id,
    :client_secret,
    :authorization_endpoint,
    :token_endpoint,
    :logout_endpoint,
    :grant_type,
    :auth_status,
    :additional_params,
    :scopes
  ]

  @type t :: %KindeClientSDK{
          additional_params: map,
          auth_status: atom,
          authorization_endpoint: binary,
          cache_pid: pid,
          client_id: any,
          client_secret: any,
          domain: binary,
          grant_type: any,
          logout_endpoint: binary,
          logout_redirect_uri: any,
          redirect_uri: binary,
          scopes: any,
          token_endpoint: binary
        }

  @doc """
  Used for initializing the Kinde client which will be then used other implemented client functions,
  like `login` and `get_token`.

  Initialize your client like this:

      {conn, client} =
        KindeClientSDK.init(
          conn,
          Application.get_env(:kinde_sdk, :domain),
          Application.get_env(:kinde_sdk, :redirect_url),
          Application.get_env(:kinde_sdk, :backend_client_id),
          Application.get_env(:kinde_sdk, :client_secret),
          :client_credentials,
          Application.get_env(:kinde_sdk, :logout_redirect_url)
        )

  `conn` will be phoenix connection here here.

  `scopes` is an optional and defaults to `"openid profile email offline"`. Scopes can be defined as string.

  `additional_params` is an optional and defaults to `%{}`. It accepts `:audience`, `:org_code` and
  `:org_name` keys in the map with string as values.

  Throws for invalid `domain`, `redirect_uri` and `additional_params`.
  """
  @spec init(Plug.Conn.t(), binary, binary, any, any, any, any, binary, map) ::
          {Plug.Conn.t(), map()}
  def init(
        conn,
        domain,
        redirect_uri,
        client_id,
        client_secret,
        grant_type,
        logout_redirect_uri,
        scopes \\ "openid profile email offline",
        additional_params \\ %{}
      ) do
    if !Utils.validate_url(domain) do
      throw("Please provide valid domain")
    end

    if !Utils.validate_url(redirect_uri) do
      throw("Please provide valid redirect_uri")
    end

    {:ok, pid} = KindeCache.start()
    conn = Conn.put_session(conn, :kinde_cache_pid, pid)

    client = %__MODULE__{
      cache_pid: pid,
      domain: domain,
      redirect_uri: redirect_uri,
      client_secret: client_secret,
      client_id: client_id,
      grant_type: grant_type,
      additional_params: Utils.check_additional_params(additional_params),
      logout_redirect_uri: logout_redirect_uri,
      scopes: scopes,
      authorization_endpoint: "#{domain}#{@authorization_end_point}",
      token_endpoint: "#{domain}#{@token_end_point}",
      logout_endpoint: "#{domain}#{@logout_end_point}",
      auth_status: :unauthenticated
    }

    save_kinde_client(conn, client)

    {conn, client}
  end

  @doc """
  Login function for KindeClient. If grant type is `:client_credentials`, then access token will be generated
  and stored to KindeCache. For other grant types, returned `conn` will redirect to the your Kinde business login page.

  Your callback function will call `get_token` function to get the authenticated user's token.

  ### Usage

        conn = KindeClientSDK.login(conn, client)

  `additional_params` is an optional and defaults to `%{}`. It accepts `:audience`, `:org_code` and
  `:org_name` keys in the map with string as values.

  Throws for invalid `grant_type`.
  """
  @spec login(
          Plug.Conn.t(),
          KindeClientSDK.t(),
          map()
        ) :: any
  def login(conn, client, additional_params \\ %{}) do
    clean_session(client.cache_pid)
    client = update_auth_status(client, :authenticating)

    case client.grant_type do
      :client_credentials ->
        ClientCredentials.login(conn, client, additional_params)

      :authorization_code ->
        AuthorizationCode.login(conn, client, additional_params)

      :authorization_code_flow_pkce ->
        Pkce.login(conn, client, :login, additional_params)

      _ ->
        update_auth_status(client, :unauthenticated)
        throw("Please provide correct grant_type")
    end
  end

  @doc """
  Register function for your KindeClient. Returing `conn` will redirect to the your Kinde business registration page.

  ### Usage

        conn = KindeClientSDK.register(conn, client)

  `additional_params` is an optional and defaults to `%{}`. It accepts `:audience`, `:org_code` and
  `:org_name` keys in the map with string as values.
  """
  @spec register(
          Plug.Conn.t(),
          KindeClientSDK.t(),
          map()
        ) :: Plug.Conn.t()
  def register(conn, client, additional_params \\ %{}) do
    client = update_auth_status(client, :authenticating)
    client = %{client | grant_type: :authorization_code}
    Pkce.login(conn, client, :registration, additional_params)
  end

  @doc """
  The function allows you to create organization. Similar to register, the returing `conn` will redirect
  to the your Kinde business registration page.

  ### Usage

        conn = KindeClientSDK.create_org(conn, client)

  `additional_params` is an optional and defaults to `%{}`. It accepts `:audience`, `:org_code` and
  `:org_name` keys in the map with string as values.
  """
  @spec create_org(
          Plug.Conn.t(),
          KindeClientSDK.t(),
          map()
        ) :: Plug.Conn.t()
  def create_org(conn, client, additional_params \\ %{}) do
    additional_params = Map.put(additional_params, :is_create_org, "true")
    register(conn, client, additional_params)
  end

  @doc """
  Fetches the tokens for your KindeClient. The tokens can be obtained through Kinde cache afterwards.

  ### Usage

        {conn, client} = KindeClientSDK.get_token(conn)

  Get the tokens like this:

        pid = Conn.get_session(conn, :kinde_cache_pid)
        GenServer.call(pid, {:get_kinde_data, :kinde_access_token})
  """
  @spec get_token(Plug.Conn.t()) ::
          {Plug.Conn.t(), map()}
  def get_token(conn) do
    client = get_kinde_client(conn)
    do_get_token(conn, client.grant_type)
  end

  defp do_get_token(conn, :client_credentials) do
    client = get_kinde_client(conn)

    conn = ClientCredentials.login(conn, client)

    client = get_kinde_client(conn)
    {conn, client}
  end

  defp do_get_token(conn, grant_type)
       when grant_type in [:authorization_code, :authorization_code_flow_pkce] do
    client = get_kinde_client(conn)
    expiring_timestamp = return_key(client.cache_pid, :kinde_expiring_time_stamp)

    form_params = %{
      client_id: client.client_id,
      client_secret: client.client_secret,
      grant_type: get_grant_type(client.grant_type),
      redirect_uri: client.redirect_uri,
      response_type: :code
    }

    if is_nil(expiring_timestamp) do
      %{"state" => state, "code" => authorization_code} =
        Conn.fetch_query_params(conn).query_params

      check_state_authentication(client.cache_pid, state)

      error = Conn.fetch_query_params(conn).query_params["error"]

      if error do
        error_description = Conn.fetch_query_params(conn).query_params["error_description"]
        message = error_description || error
        throw(message)
      end

      if is_nil(authorization_code), do: throw("Not found code param")
      form_params = Map.put(form_params, :code, authorization_code)

      code_verifier = get_all_data(conn).oauth_code_verifier

      form_params =
        cond do
          code_verifier ->
            Map.put(form_params, :code_verifier, code_verifier)

          client.grant_type == :authorization_code_flow_pkce ->
            throw("Not found code_verifier")

          true ->
            form_params
        end

      get_a_new_token(form_params, client)
    else
      fetch_token_with_expiring_timestamps(conn, expiring_timestamp, form_params, client)
    end

    client = update_auth_status(client, :authenticated)
    save_kinde_client(conn, client)

    {conn, client}
  end

  defp do_get_token(_, _) do
    throw("Please provide correct grant_type")
  end

  defp fetch_token_with_expiring_timestamps(conn, expiring_timestamp, form_params, client) do
    case DateTime.compare(expiring_timestamp, DateTime.utc_now()) do
      :gt ->
        get_all_data(conn)

      :lt ->
        refresh_token_params =
          form_params
          |> Map.merge(%{
            grant_type: :refresh_token,
            refresh_token: return_key(client.cache_pid, :kinde_refresh_token)
          })

        get_a_new_token(refresh_token_params, client)

      _ ->
        "Access/Refresh Tokens are invalid"
    end
  end

  defp get_a_new_token(params, client) do
    body = {:form, params |> Map.to_list()}

    {:ok, response} =
      HTTPoison.post(
        client.token_endpoint,
        body,
        [
          {"Kinde-SDK", "Elixir/#{Utils.get_current_app_version()}"}
        ]
      )

    body = Jason.decode!(response.body)
    GenServer.cast(client.cache_pid, {:add_kinde_data, {:kinde_token, body}})
    save_data_to_session(client.cache_pid, body)
  end

  defp save_data_to_session(pid, token) do
    expires_in = if is_nil(token["expires_in"]), do: 0, else: token["expires_in"]

    GenServer.cast(pid, {:add_kinde_data, {:kinde_login_time_stamp, DateTime.utc_now()}})

    GenServer.cast(
      pid,
      {:add_kinde_data,
       {:kinde_expiring_time_stamp,
        Utils.calculate_expiring_timestamp(DateTime.utc_now(), expires_in)}}
    )

    GenServer.cast(pid, {:add_kinde_data, {:kinde_access_token, token["access_token"]}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_id_token, token["id_token"]}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_refresh_token, token["refresh_token"]}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_expires_in, expires_in}})

    payload = Utils.parse_jwt(token["id_token"])

    if is_nil(payload) do
      GenServer.cast(pid, {:add_kinde_data, {:kinde_user, nil}})
    else
      user = %{
        id: payload["sub"],
        given_name: payload["given_name"],
        family_name: payload["family_name"],
        email: payload["email"],
        picture: payload["picture"]
      }

      GenServer.cast(
        pid,
        {:add_kinde_data, {:kinde_user, user}}
      )
    end
  end

  @doc """
  Returns the user details after successful authentication.

  ### Usage
        KindeClientSDK.get_user_detail(conn)

  Returns `nil` if not authenticated or if grant type is `:client_credentials`.
  """
  @spec get_user_detail(Plug.Conn.t()) :: any
  def get_user_detail(conn) do
    data = get_all_data(conn)

    data.user
  end

  @doc """
  Log outs your client. Returned `conn` redirects to you to Kinde logout page and
  returns back to your logout redirect url.

  ### Usage
        conn = KindeClientSDK.logout(conn)
  """
  @spec logout(Plug.Conn.t()) :: Plug.Conn.t()
  def logout(conn) do
    client = get_kinde_client(conn)

    pid = Conn.get_session(conn, :kinde_cache_pid)
    clean_session(pid)
    client = update_auth_status(client, :unauthenticated)
    save_kinde_client(conn, client)

    search_params = %{redirect: client.logout_redirect_uri}

    query_params = URI.encode_query(search_params)

    conn =
      conn
      |> Plug.Conn.resp(:found, "")
      |> Plug.Conn.put_resp_header("location", "#{client.logout_endpoint}?#{query_params}")

    conn
  end

  @doc """
  Returns new grant type. Used by `get_token` function.
  """
  @spec get_grant_type(:authorization_code | :authorization_code_flow_pkce | :client_credentials) ::
          :authorization_code | :client_credentials
  def get_grant_type(type) do
    case type do
      :client_credentials ->
        :client_credentials

      :authorization_code ->
        :authorization_code

      :authorization_code_flow_pkce ->
        :authorization_code

      _ ->
        throw("Please provide correct grant_type")
    end
  end

  @doc """
  Returns whether if a user is logged in by verifying that the access token is still valid.

  ### Usage
        KindeClientSDK.authenticated?(conn)
  """
  @spec authenticated?(Plug.Conn.t()) :: boolean
  def authenticated?(conn) do
    data = get_all_data(conn)

    timestamp = data.login_time_stamp
    expires_in = data.expires_in

    if is_nil(timestamp) or is_nil(expires_in) do
      false
    else
      DateTime.diff(DateTime.utc_now(), timestamp) < expires_in
    end
  end

  @doc """
  Returns token claims and their value.

  ### Usage

  Second argument defaults to `:access_token`

        KindeClientSDK.get_claims(conn)

  If used with `:id_token`

        KindeClientSDK.get_claims(conn, :id_token)
  """
  @spec get_claims(Plug.Conn.t(), any) :: any
  def get_claims(conn, token_type \\ :access_token) do
    if !(token_type in [:access_token, :id_token]) do
      throw("Please provide valid token (access_token or id_token) to get claim")
    end

    key = String.to_atom("kinde_#{token_type}")

    pid = Conn.get_session(conn, :kinde_cache_pid)

    token =
      case GenServer.call(pid, {:get_kinde_data, key}) do
        [kinde_access_token: data] -> data
        [kinde_id_token: data] -> data
        _ -> nil
      end

    if is_nil(token) do
      throw("Request is missing required authentication credential")
    end

    Utils.parse_jwt(token)
  end

  @doc """
  Returns a single claim object from token and its name and value.

  ### Usage

  Third argument defaults to `:access_token`

        KindeClientSDK.get_claim(conn, "jti")

  If used with `:id_token`

        KindeClientSDK.get_claim(conn, "jti", :id_token)
  """
  @spec get_claim(Plug.Conn.t(), any, any) :: any
  def get_claim(conn, key, token_type \\ :access_token) do
    data = get_claims(conn, token_type)

    %{
      name: key,
      value: data[key]
    }
  end

  @doc """
  Returns an object with a list of permissions and also the relevant org code.

  ### Usage

        KindeClientSDK.get_permissions(conn)
        KindeClientSDK.get_permissions(conn, :id_token)
  """
  @spec get_permissions(Plug.Conn.t(), any) :: %{org_code: any, permissions: any}
  def get_permissions(conn, token_type \\ :access_token) do
    claims = get_claims(conn, token_type)
    %{org_code: claims["org_code"], permissions: claims["permissions"]}
  end

  @doc """
  Given a permission value, returns if it is granted or not and relevant org code.

  ### Usage

        KindeClientSDK.get_permission(conn, "create:users")
        KindeClientSDK.get_permission(conn, "create:users", :id_token)
  """
  @spec get_permission(Plug.Conn.t(), any, any) :: %{is_granted: boolean, org_code: any}
  def get_permission(conn, permission, token_type \\ :access_token) do
    all_claims = get_claims(conn, token_type)
    permissions = all_claims["permissions"]
    %{org_code: all_claims["org_code"], is_granted: permission in permissions}
  end

  @doc """
  Returns the org code from the claims.

  ### Usage
        KindeClientSDK.get_user_organization(conn)
  """
  @spec get_organization(Plug.Conn.t()) :: %{org_code: any}
  def get_organization(conn) do
    %{org_code: get_claim(conn, "org_code", :id_token)}
  end

  @doc """
  Returns the org code from the user token.

  ### Usage
        KindeClientSDK.get_user_organizations(conn)
  """
  @spec get_user_organizations(Plug.Conn.t()) :: %{org_codes: any}
  def get_user_organizations(conn) do
    %{org_codes: get_claim(conn, "org_codes", :id_token)}
  end

  @doc """
  Returns the authentication status.

  ### Usage
        KindeClientSDK.get_auth_status(conn)
  """
  @spec get_auth_status(Plug.Conn.t()) :: any
  def get_auth_status(conn) do
    Conn.get_session(conn, :kinde_auth_status)
  end

  defp update_auth_status(client, status) do
    GenServer.cast(client.cache_pid, {:add_kinde_data, {:kinde_auth_status, status}})
    %{client | auth_status: status}
  end

  defp clean_session(pid) do
    GenServer.cast(pid, {:add_kinde_data, {:kinde_token, nil}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_access_token, nil}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_id_token, nil}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_auth_status, nil}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_oauth_state, nil}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_oauth_code_verifier, nil}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_expires_in, nil}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_login_time_stamp, nil}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_user, nil}})
  end

  defp check_state_authentication(pid, server_state) do
    [kinde_oauth_state: oauth_state] = GenServer.call(pid, {:get_kinde_data, :kinde_oauth_state})

    if is_nil(oauth_state) or server_state != oauth_state do
      throw("Authentication failed because it tries to validate state")
    end
  end

  @doc """
  Returns the Kinde client created from the `conn`.

  ### Usage
        client = KindeClientSDK.get_kinde_client(conn)
  """
  @spec get_kinde_client(Plug.Conn.t()) :: map()
  def get_kinde_client(conn) do
    [kinde_client: client] =
      Conn.get_session(conn, :kinde_cache_pid)
      |> GenServer.call({:get_kinde_data, :kinde_client})

    client
  end

  @doc """
  Saves the Kinde client created into the `conn`.

  ### Usage
        KindeClientSDK.save_kinde_client(conn)
  """
  @spec save_kinde_client(Plug.Conn.t(), any) :: :ok
  def save_kinde_client(conn, client) do
    Conn.get_session(conn, :kinde_cache_pid)
    |> GenServer.cast({:add_kinde_data, {:kinde_client, client}})
  end

  @doc """
  Returns the Kinde cache PID from the `conn`.

  ### Usage
        pid = KindeClientSDK.get_cache_pid(conn)
  """
  @spec get_cache_pid(Plug.Conn.t()) :: any
  def get_cache_pid(conn) do
    Conn.get_session(conn, :kinde_cache_pid)
  end

  @doc """
  Returns all the Kinde data (tokens) returned.

  ### Usage
        data = KindeClientSDK.get_all_data(conn)
        IO.inspect(data.access_token, label: "Access Token")
  """
  @spec get_all_data(Plug.Conn.t()) :: %{
          access_token: any,
          refresh_token: any,
          expires_in: any,
          id_token: any,
          login_time_stamp: any,
          expiring_time_stamp: any,
          token: any,
          user: any,
          oauth_code_verifier: any
        }
  def get_all_data(conn) do
    pid = get_cache_pid(conn)

    %{
      login_time_stamp: return_key(pid, :kinde_login_time_stamp),
      expiring_time_stamp: return_key(pid, :kinde_expiring_time_stamp),
      access_token: return_key(pid, :kinde_access_token),
      refresh_token: return_key(pid, :kinde_refresh_token),
      id_token: return_key(pid, :kinde_id_token),
      expires_in: return_key(pid, :kinde_expires_in),
      token: return_key(pid, :kinde_token),
      user: return_key(pid, :kinde_user),
      oauth_code_verifier: return_key(pid, :kinde_oauth_code_verifier)
    }
  end

  @doc """
    Returns more readible version of any feature-flag

    ### Returns

          feature-flag map such as

          %{
            "code" => "theme",
            "is_default" => false,
            "type" => "string",
            "value" => "grayscale"
          }

    ### Usage

          KindeClientSDK.get_flag(conn, "theme")
          KindeClientSDK.get_flag(conn, "theme", "black")
          KindeClientSDK.get_flag(conn, "theme", "black", "s")
  """
  @spec get_flag(Plug.Conn.t(), String.t()) :: map() | String.t()
  def get_flag(conn, code) do
    %{name: _claim_name, value: feature_flags} = KindeClientSDK.get_claim(conn, "feature_flags")

    case feature_flags[code] do
      nil ->
        "This flag does not exist, and no default value provided"

      %{"t" => flag_type, "v" => value} ->
        %{
          "code" => code,
          "type" => get_type(flag_type),
          "value" => value,
          "is_default" => false
        }
    end
  end

  @spec get_flag(Plug.Conn.t(), String.t(), any()) :: map() | String.t()
  def get_flag(conn, code, default_value) do
    %{name: _claim_name, value: feature_flags} = KindeClientSDK.get_claim(conn, "feature_flags")

    case feature_flags[code] do
      nil ->
        %{
          "code" => code,
          "value" => default_value,
          "is_default" => true
        }

      _ ->
        get_flag(conn, code)
    end
  end

  @spec get_flag(Plug.Conn.t(), String.t(), any(), String.t()) :: map() | String.t()
  def get_flag(conn, code, default_value, flag_type) do
    %{name: _claim_name, value: feature_flags} = KindeClientSDK.get_claim(conn, "feature_flags")

    case feature_flags[code] do
      %{"t" => actual_type} when actual_type != flag_type ->
        "The flag type was provided as #{get_type(flag_type)}, but it is #{get_type(actual_type)}"

      _ ->
        get_flag(conn, code, default_value)
    end
  end

  @doc """
    Returns a boolean flag from feature-flags object

    ### Returns

          true, false or error-messages

    ### Usage

          KindeClientSDK.get_boolean_flag(conn, "is_dark_mode")
          KindeClientSDK.get_boolean_flag(conn, "is_dark_mode", false)
  """
  @spec get_boolean_flag(Plug.Conn.t(), String.t()) :: boolean() | String.t()
  def get_boolean_flag(conn, code) do
    %{name: _claim_name, value: feature_flags} = KindeClientSDK.get_claim(conn, "feature_flags")

    case feature_flags[code] do
      %{"t" => "b", "v" => value} ->
        value

      %{"t" => type} ->
        "Error - Flag #{code} is of type #{get_type(type)} not boolean"

      _ ->
        "Error - flag does not exist and no default provided"
    end
  end

  @spec get_boolean_flag(Plug.Conn.t(), String.t(), boolean()) :: boolean() | String.t()
  def get_boolean_flag(conn, code, default_value) do
    %{name: _claim_name, value: feature_flags} = KindeClientSDK.get_claim(conn, "feature_flags")

    case feature_flags[code] do
      nil ->
        default_value

      %{"t" => "b", "v" => value} ->
        value

      %{"t" => type, "v" => _} ->
        "Error - Flag #{code} is of type #{get_type(type)} not boolean"
    end
  end

  @doc """
    Returns a string flag from feature-flags object

    ### Returns

          corresponding values from object or error-messages

    ### Usage

          KindeClientSDK.get_string_flag(conn, "theme")
          KindeClientSDK.get_string_flag(conn, "theme", "black")
  """
  @spec get_string_flag(Plug.Conn.t(), String.t()) :: String.t()
  def get_string_flag(conn, code) do
    %{name: _claim_name, value: feature_flags} = KindeClientSDK.get_claim(conn, "feature_flags")

    case feature_flags[code] do
      %{"t" => "s", "v" => value} ->
        value

      %{"t" => type} ->
        "Error - Flag #{code} is of type #{get_type(type)} not string"

      _ ->
        "Error - flag does not exist and no default provided"
    end
  end

  @spec get_string_flag(Plug.Conn.t(), String.t(), String.t()) :: String.t()
  def get_string_flag(conn, code, default_value) do
    %{name: _claim_name, value: feature_flags} = KindeClientSDK.get_claim(conn, "feature_flags")

    case feature_flags[code] do
      nil ->
        default_value

      %{"t" => "s", "v" => value} ->
        value

      %{"t" => type, "v" => _} ->
        "Error - Flag #{code} is of type #{get_type(type)} not string"
    end
  end

  @doc """
    Returns a integer flag from feature-flags object

    ### Returns

          corresponding values from object or error-messages

    ### Usage

          KindeClientSDK.get_integer_flag(conn, "counter")
          KindeClientSDK.get_integer_flag(conn, "counter", 46)
  """

  @spec get_integer_flag(Plug.Conn.t(), String.t()) :: integer() | String.t()
  def get_integer_flag(conn, code) do
    %{name: _claim_name, value: feature_flags} = KindeClientSDK.get_claim(conn, "feature_flags")

    case feature_flags[code] do
      %{"t" => "i", "v" => value} ->
        value

      %{"t" => type} ->
        "Error - Flag #{code} is of type #{get_type(type)} not integer"

      _ ->
        "Error - flag does not exist and no default provided"
    end
  end

  @spec get_integer_flag(Plug.Conn.t(), String.t(), integer()) :: integer() | String.t()
  def get_integer_flag(conn, code, default_value) do
    %{name: _claim_name, value: feature_flags} = KindeClientSDK.get_claim(conn, "feature_flags")

    case feature_flags[code] do
      nil ->
        default_value

      %{"t" => "i", "v" => value} ->
        value

      %{"t" => type, "v" => _} ->
        "Error - Flag #{code} is of type #{get_type(type)} not integer"
    end
  end

  defp get_type(flag) when is_map(flag) do
    type = flag["t"]

    case type do
      "i" ->
        "integer"

      "s" ->
        "string"

      "b" ->
        "boolean"

      _ ->
        "undefined"
    end
  end

  defp get_type(flag) do
    case flag do
      "i" ->
        "integer"

      "s" ->
        "string"

      "b" ->
        "boolean"

      _ ->
        "undefined"
    end
  end

  defp return_key(pid, key) do
    case GenServer.call(pid, {:get_kinde_data, key}) do
      [{_, data}] -> data
      _ -> nil
    end
  end
end
